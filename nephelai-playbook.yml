---
- include: setup-playbook.yml


- name: install aws cli

  hosts: local

  tasks:

    - name: install packages
      local_action:
        module: pip
        name: 
          - awscli
      become: yes

    - name: create inventory groups
      local_action:
        module: lineinfile
        line: '[jupyter]'
        dest: 'inventory/aws'
        insertafter: EOF
        create: yes


- name: provision jupyter.nephelai.io artifacts

  hosts: local

  vars_files: 
    - vars/nephelai.yml

  tasks:

    - name: retrieve vpc_id
      local_action: command aws ec2 describe-vpcs --region {{ region }} --filters "Name=tag:Name,Values={{ vpc_name }}" --query "Vpcs[*].VpcId" --output text
      register: vpc_id
      changed_when: false

    - name: retrieve image id
      local_action:
        module: ec2_ami_find
        name: "{{ ami_name }}"
        owner: "{{ ami_owner }}"
        sort: name
        sort_order: descending
        sort_end: 1
        region: "{{ region }}"
      register: ami
      changed_when: false

    - name: retrieve subnet id
      local_action: command aws ec2 describe-subnets --region {{ region }} --filter Name=vpc-id,Values={{ vpc_id.stdout }},Name=availability-zone,Values={{ region }}{{availability_zone}} --query "Subnets[*].SubnetId" --output text
      register: subnet_id
      changed_when: false

    - name: delete jupyter security group
      local_action:
        module: ec2_group
        name: jupyter
        region: "{{ region }}"
        description: Jupyter access group
        state: absent

    - name: create http security group
      local_action:
        module: ec2_group
        name: httpd
        region: "{{ region }}"
        description: HTTP access group
        state: present
        vpc_id: "{{ vpc_id.stdout }}"
        rules:
          - proto: tcp
            from_port: 80
            to_port: 80
            cidr_ip: 0.0.0.0/0
          - proto: tcp
            from_port: 443
            to_port: 443
            cidr_ip: 0.0.0.0/0
          - proto: tcp
            from_port: 22
            to_port: 22
            cidr_ip: 0.0.0.0/0
          - proto: icmp
            from_port: 8
            to_port: -1
            cidr_ip: 0.0.0.0/0
        rules_egress:
          - proto: tcp
            from_port: 0
            to_port: 65535
            cidr_ip: 0.0.0.0/0
          - proto: udp
            from_port: 0
            to_port: 65535
            cidr_ip: 0.0.0.0/0
          - proto: icmp
            from_port: 8
            to_port: -1
            cidr_ip: 0.0.0.0/0

    - name: retrieve instance ids
      local_action: command aws ec2 describe-instances --region {{ region }} --filter Name=client-token,Values={{ client_token }} --query "Reservations[].Instances[].InstanceId"
      register: instance_query
      changed_when: false

    - block:

      - name: provision jupyter instances
        local_action:
          module: ec2
          region: "{{ region }}"
          vpc_subnet_id: "{{ subnet_id.stdout }}"
          instance_type: "{{ instance_type }}"
          id: "{{ client_token }}"
          instance_ids: "{{ instance_query.stdout | from_json | list }}"
          image: "{{ ami.results[0].ami_id }}"
          state: "{{ state }}"
          count: "{{ instance_count }}"
          key_name: "{{ key }}"
          groups:
            - httpd
        register: ec2

      - name: provision persistent inventory
        local_action:
          module: lineinfile
          dest: 'inventory/aws'
          insertafter: '[jupyter]'
          line: "{{ item.public_dns_name }}"
          create: true
          state: "{{ state }}"
        with_items: "{{ ec2.instances }}"

      - name: provision in-memory inventory
        local_action:
          module: add_host
          groups: jupyter
          name: "{{ item.public_dns_name }}"
        with_items: "{{ ec2.instances }}"

      - name: tag instances
        local_action:
          module: ec2_tag
          resource: "{{ item.id }}"
          region: "{{ region }}"
          state: "{{ state }}"
          tags: 
            stack: jupyter
        with_items: "{{ ec2.instances }}"
        when: state == 'present'

      when: 
        - state in ['present'] or ((state == 'absent') and (instance_query.stdout | from_json | length > 0))

    - name: retrieve route53 zone
      local_action: command aws route53 list-hosted-zones --query 'HostedZones[?Name==`{{ route53_zone }}`].Id' --output text
      register: route53_zone_query
      changed_when: false

    - name: retrieve route53 record
      local_action: command aws route53 list-resource-record-sets --hosted-zone-id={{ route53_zone_query.stdout }} --query "ResourceRecordSets[?Name==`jupyter.{{ route53_zone }}`]"
      register: route53_rrs_query
      changed_when: false

    - name: delete route53 record
      local_action:
        module: route53
        command: delete
        zone: "{{ route53_zone }}"
        record: "{{ route53_rrs_query.stdout | from_json | map(attribute='Name') | list | first | string }}"
        value: "{{ item | string }}"
        type: "{{ route53_rrs_query.stdout | from_json | map(attribute='Type') | list | first | string }}"
      with_items: "{{ route53_rrs_query.stdout | from_json | map(attribute='ResourceRecords') | list | first | map(attribute='Value') | list }}"
      when: 
        - not state in ['stopped', 'present']
        - route53_rrs_query.stdout | string != '[]'
        - route53_rrs_query.stdout | from_json | map(attribute='ResourceRecords') | list | first | map(attribute='Value') | list | length > 0

    - name: retrieve instances
      local_action: command aws ec2 describe-instances --region {{ region }} --filter Name=client-token,Values={{ client_token }} --query "Reservations[].Instances[]"
      register: instance_query
      changed_when: false

    - name: manage jupyter instances
      local_action:
        module: ec2
        region: "{{ region }}"
        id: "{{ client_token }}"
        instance_ids: "{{ instance_query.stdout | from_json | map(attribute='InstanceId') | list }}"
        state: "{{ state }}"
      when: 
        - (instance_query.stdout | from_json | length > 0) and (state in ['stopped', 'running'])

    - block:

      - name: wait for ssh
        local_action:
          module: wait_for
          host: "{{ item.PublicDnsName }}"
          port: 22
          state: started
        with_items: "{{ instance_query.stdout | from_json }}"

      - name: retrieve instances
        local_action: command aws ec2 describe-instances --region {{ region }} --filter Name=client-token,Values={{ client_token }} --query "Reservations[].Instances[]"
        register: instance_query
        changed_when: false

      - name: provision route53 record
        local_action:
          module: route53
          command: "{{ route53_state }}"
          zone: "{{ route53_zone }}"
          record: "jupyter.{{ route53_zone }}"
          value: "{{ instance_query.stdout | from_json | map(attribute='PublicIpAddress') | join(' ') }}"
          type: A
          overwrite: yes

      when: 
        - not state in ['stopped', 'absent']
        - instance_query | list | length > 0

    - name: destroy persistent inventory
      file: 
        dest: 'inventory/aws'
        state: absent
      when: state == 'absent'



- hosts: bootstrap jupyter nodes


- hosts: jupyter
  roles:
    - role: jdauphant.nginx
      become: yes
      nginx_sites:
        jupyter:
          - listen 80
          - server_name "jupyter.{{ route53_domain }}"
          - client_max_body_size 300M
          - |
            location / { 
              proxy_pass http://jupyter; 
              proxy_set_header Host $host; 
            }
          - |
            location ~ /api/kernels { 
              proxy_pass http://notebook;
              proxy_set_header Host $host;
              proxy_http_version 1.1;
              proxy_set_header Upgrade "websocket";
              proxy_set_header Connection "Upgrade";
              proxy_read_timeout 86400;
            }
          - |
            location ~ /terminals/ {
              proxy_pass http://notebook;
              proxy_set_header Host $host;
              proxy_http_version 1.1;
              proxy_set_header Upgrade "websocket";
              proxy_set_header Connection "Upgrade";
              proxy_read_timeout 86400;
            }
      nginx_configs:
        upstream:
          - upstream jupyter { server localhost:8888; }

